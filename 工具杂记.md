### 杂记

#### OpenSSH

OpenSSH 是使用SSH协议进行远程登录的主要连接工具。它加密所有流量以消除窃听、连接劫持和其他攻击。此外，OpenSSH提供了大量的安全隧道功能、多种身份验证方法和复杂的配置选项。

OpenSSH套件包含以下工具：

- 远程操作工具
  
  - ssh — OpenSSH远程登录客户端
    
    ssh（SSH 客户端）是一个用于登录远程机器并在远程机器上执行命令的程序。它旨在通过不安全的网络在两个不受信任的主机之间提供安全的加密通信。ssh连接并登录到`[user@]hostname`或`ssh://[user@]hostname[:port]`指定的主机。
  
  - scp — OpenSSH 安全文件传输
    
    scp 在网络上的主机之间复制文件。它使用 ssh进行数据传输，使用相同的身份验证并提供与登录会话相同的安全性。
  
  - sftp

- 密钥管理工具
  
  - ssh-add
  
  - ssh-keysign
  
  - ssh-keyscan
  
  - ssh-keygen

- 服务端工具
  
  - sshd
  
  - sftp-server
  
  - ssh-agent

#### vmlinuz——Linux 内核可执行文件

- vmlinuz 是一个压缩的 Linux 内核，可引导。可引导意味着它能够将操作系统加载到内存中，以便计算机变得可用并且可以运行应用程序。vmlinuz不仅仅是一个压缩镜像，它还内置了 gzip 解压缩器代码。

- 而vmlinux 是一个静态链接的可执行文件，它包含Linux内核，采用Linux支持的目标文件格式之一，包括可执行和可链接格式（Executable and Linkable Format, ELF）、通用目标文件格式（Common Object File, COFF）和a.out。内核调试、符号表生成或其他操作可能需要vmlinux文件，但在用作操作系统内核之前必须通过添加多引导头（multiboot header）、引导扇区（bootsector）和设置例程（setup routines）使其可引导。

- vmlinuz 不应与 vmlinux 混淆，后者是非压缩和不可引导形式的内核。 vmlinux 通常只是生成 vmlinuz 的中间步骤。

- vmlinuz在/boot目录下，该目录包含开始引导系统所需的文件。名为vmlinuz的文件可能是实际的内核可执行文件本身，也可能是内核可执行文件的链接（链接文件使用ls -l 查看时以字母l开始）。其名称也可能为特定内核版本

##### vmlinuz词源

UNIX平台称这种内核镜像为`/unix`。由于虚拟内存的发展，支持这种特征的内核有了`vm-`前缀以示区分。`vmlinux`是`vmunix`的变种，而`vmlinuz`尾部的`z`表示已压缩。

#### initrd —— Initial ramdisk 临时文件系统

在Linux系统中，initrd是一种将临时根文件系统加载到内存中的方案，用作Linux启动过程的一部分。`initrd`和`initramfs`是两种不同的实现方法。两者通常用于在真实根文件系统可以挂载之前做准备。

#### read command in linux

```shell
$ read [options] [name...]
```

options 影响read命令如何与输入交互

name 指定将拆分操作产生的实际单词存储在哪些变量中

```shell
$ read    # read 默认行为从标准输入流获取一行并将其赋值于内置变量REPLY
This is a cool person
$ echo $REPLY
This is a cool person
$ read input1 input2 input3
> This is a cooool person
$ echo "[$input1] [$input2] [$input3]"
[This] [is] [a cooool person]
# 如果变量的数量少于获得的单词，则所有剩余的单词及其分隔符都赋给最后一个变量。
```

默认情况下，read命令将输入拆分为单词，将<space>, <tab> 和 <newline> 字符视为分隔符。

##### Internal Field Separator

内部字符分隔符（IFS）确定给定行中的字边界。

```shell
$ {
    IFS=";"
    read input1 input2 input3
    echo "[$input1] [$input2] [$input3]"
}
This;;is;a;cool;boy
[This] [] [is;a;cool;boy]
```

```shell
$ {
    IFS=" "
    read input1 input2 input3
    echo "[$input1] [$input2] [$input3]"
}
This is  a cool boy
[This] [is] [a cool boy]
```

空格分词的行为特殊，一个空格序列被视为一个分隔符。

##### 基础选项

- `-a` 数组，将单词拆分操作的结果存储在数组中而不是单独的变量中

- `-e` 使用Bash内置的readline库读取输入行

- `-s` 不要将输入行回显到标准输出流（密码实现不显示输入）

- `-p` 提示，在从标准输入流中请求输入之前打印提示文本，不带<newline>字符

- `-i` 文本，在标准输出流上打印文本作为默认输入（只能与-e结合使用）

```shell
# 使用 -s 和 -i 选项实现简易密码提示，以及隐藏字符
$ {
    read -p "username:" USERNAME
    read -p "password:" -s PASSWORD
    echo
    echo -e "USERNAME:$USERNAME PASSWORD:$PASSWORD"
}
# username:yang
# password:
# USERNAME:yang PASSWORD:yongy
```

某些情况下，单词的数量因输入而异，需要利用数组。

```shell
$ {
    declare -a input_array
    text="This is default input"
    read -e -i "$text" -a input_array
    for input in "${input_array[@]}"
        do
            echo -n "[$input] "
        done
}
$ {
    read input1-abc    # invalid variable
    echo "return code [$?]"
}
# bash: read: `input1-abc': not a valid identifier
# return code [1]
$ {
    read input1_abc
    echo "return code [$?]"
}
# return code [0]
```

##### 高级选项

- `-d` delim（限界符），指定输入行的限界符而不是使用换行符。

- `-u` fd，从给定文件描述符读取输入行

- `-r` backslash不再转义字符

- `-t` timeout，尝试在给定的秒数内读取输入

- `-N` 从输入中读N个字符除非发生了超时或到达了EOF

##### Read from Files

`exec <filename` 命令将标准输入重定向到文件。从该命令开始，所有标准输入来自该文件，而非它的通常源（键盘输入）。提供一种方式按行读取文件，以及使用`sed`和/或`awk`对每行进行可能的分析。

```shell
#！/bin/bash
# Redirecting stdin using 'exec'

exec 6<&0    # 将文件表述符#6与标准输入stdin链接，保存标准输入

exec < data-file    # 标准输入被文件“data-file"替代

read a1    # 读取文件"data-file"的第一行
read a2    # 读取文件"data-file"的第二行
echo
echo "----------------------------"
echo $a1
echo $a2
echo; echo;
exec 0<&6 6<&-    #从fd #6中恢复标准输入stdin， 并关闭fd #6 ,释放它以便其他进程使用
# <&6 6<&- also works
echo -n "Enter data "
read b1 # 现在从标准输入中读取
echo "-----------------------------"
echo "b1 = $b1"
echo
exit 0
```

同样，exec >filename 命令将标准输出重定向到指定文件。将命令标准输出输出到该文件。

##### 从其他命令读取（pipe redirection）

# 

#### 如何创建补丁文件？

- 使用`diff`
  
  diff 是补丁文件的起源，要求有新旧两份代码副本。假设两份副本在文件夹old和new下。
  
  ```shell
  $ diff -Naur old new > patch.txt
  # -r 递归，设置后diff会将两个不同版本源代码目录中的所有对应文件全部进行一次比较
  #    包括子目录文件
  # -N 选项确保补丁文件将正确地处理已经创建或删除文件的情况
  # -u, -U NUM, --unified[=NUM]
  #    输出每个修改前后的3行（默认），也可以通过设置NUM输出更多的上下文
  ```
  
  使用`patch`应用补丁: `patch [options] [originalfile [patchfile]]

- 使用`git`
  
  使用git不需要未变副本模板来区分。
  
  - 为最近一次提交创建补丁
    
    ```shell
    git show > patch.txt
    ```
  
  - 在两个特定提交之间创建补丁
    
    ```shell
    git diff commitid1 commitid2 > patch.txt
    ```
  
  - 工具`format-patch`，用于格式化补丁以作为电子邮件发送
    
    为最后n个修订创建补丁（将在当前目录创建补丁，`-o` 允许指定不同的输出目录）
    
    ```shell
    git format-patch -n 
    ```
